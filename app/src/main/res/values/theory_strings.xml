<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="theory.title">Теория</string>
    <string name="theory.1">Введение</string>
    <string name="theory.2">Типы данных</string>
    <string name="theory.3">Операторы присваивания</string>
    <string name="theory.4">Простейшая арифметика и строки</string>
    <string name="theory.5">Условные выражения и конструкции</string>
    <string name="theory.6">Цикл for</string>
    <string name="theory.7">Цикл с пред- и постусловием</string>
    <string name="theory.8">Массивы</string>
    <string name="theory.9">Сортировка массива</string>
    <string name="theory.10">Матрицы и массивы массивов</string>
    <string name="theory.11">Методы</string>
    <string name="theory.12">Перегрузка методов</string>
    <string name="theory.13">Рекурсия</string>

    <string name="theory.1.text">"    "Мир каждого языка программирования велик и многообразен, полное описание всех функций и особенностей лишь только одного языка порой занимает сотни страниц. Исходя из этого, справочная информация в данном приложении покрывает лишь основные моменты языка C#.
        \n"    "Для более глубокого ознакомления со спецификой языка стоит ознакомиться с официальной документацией на сайте:
        \nhttps://docs.microsoft.com/ru-ru/dotnet/csharp/</string>

    <string name="theory.2.text">"    "В языке C# типы данных делятся на типы значений и на ссылочные типы. Давайте рассмотрим их отдельно.
        \n\nТипы значений:
        \nЦелочисленные типы: \n"    "byte(8 бит, без знака), \n"    "sbyte(8 бит, со знаком), \n"    "short(16 бит, со знаком), \n"    "ushort(16 бит, без знака), \n"    "int(32 бит, со знаком), \n"    "uint(32 бит, без знака), \n"    "long(64 бит, со знаком), \n"    "ulong(64 бит, без знака)
        \nТипы с плавающей запятой: \n"    "float(32 бит), \n"    "double(64 бит)
        \nСимволы: \n"    "char(16-разрядный код)
        \nЛогический тип: \n"    "bool(\"true\" или \"false\")
        \nДесятичный тип: \n"    "decimal(128 бит)
        \n\nСсылочные типы:
        \nОбъекты классов: \n"    "object
        \nСтроки: \n"    "string(последовательность символов)
        \n\nРассмотрим инициализацию различных типов:
        \n\nint a;
        \na = 42;
        \nВ первой строке объявлено, что a - целочисленная 32-битная переменная. Во второй строке ей присвоено значение.
        \n\ndouble b = 56.8;
        \nВ данном примере значение присваевается сразу при объявлении.
        \n\nТакже возможна инициализация нескольких переменных сразу:
        \nchar c=\'F\', d=\'r\';
        \nbool g=false, h=true;
        \n\nПрисваивать значение не объявленной ранее переменной НЕЛЬЗЯ:
        \nf = 34;
        \nДанная запись будет вызывать ошибку.</string>

    <string name="theory.3.text">"    "Оператор присваивания обозначается одиночным знаком равенства (=). В C# оператор присваивания действует таким же образом, как и в других языках программирования. \nНиже приведена его общая форма:
        \nимя_переменной = выражение

        \n\nint x, у, z;
        \nx = у = z = 10;
        \n"    "В приведенном выше фрагменте кода одно и то же значение 10 задается для переменных х, у и z с помощью единственного оператора присваивания. Это может быть удобно, если нескольким переменным присваевается одно и то же значение.

        \n\n"    "Также, существуют составные операторы присваивания:
        \nint x = 0;
        \nx = x + 1;
        \n"    "Значение переменной x увеличится на 1. Данную операцию можно переписать следующим образом:
        \nx += 1;
        \nили
        \nx++;

        \n\nОсновные составные операторы присваивания:
        \n+= (x = x + 4; эквивалентны x += 4;)
        \n-= (x = x - 4; эквивалентны x -= 4;)
        \n*= (x = x * 4; эквивалентны x *= 4;)
        \n/= (x = x / 4; эквивалентны x /= 4;)

        \n"    "У составных операторов присваивания имеются два главных преимущества. Во-первых, они более компактны, чем их "несокращенные" эквиваленты. И во-вторых, они дают более эффективный исполняемый код, поскольку левый операнд этих операторов вычисляется только один раз.</string>

    <string name="theory.4.text">"    "Строковый тип данных string относится к числу самых важных в C#. Этот тип определяет и поддерживает символьные строки. В целом ряде других языков программирования строка представляет собой массив символов. А в C# строки являются объектами. Следовательно, тип string относится к числу ссылочных.

        \n\nСамый простой способ задать символьную строку:
        \n"    "string str = "Пример строки";

        \n\nНастало время для нашей первой записи в консоли. Ниже приведен пример печати строки:
        \n"  "Console.Write("Hello, world!");
        \n"  "Console.Write(12345);
        \nили
        \n"  "Console.WriteLine("Hello, world!");
        \n"  "Console.Write(12345);

        \n\nЗаметим, что в 1-ом случае получим надпись:
        \n"  "Hello, world!12345
        \nВо 2-ом:
        \n"  "Hello, world!
        \n"  "12345
        \nЭто связано с тем, что команда Console.Write() просто выводит надпись в консоль, Console.WriteLine() - выводит надпись и переводит курсор на новую строку.

        \n\nТакже мы можем выводить результат вычислений:
        \n"  "Console.Write(44 + 6);
        \nПолучим: 50
        \n"  "Console.Write(\"44\" + \"6\");
        \nПолучим: 446
        \nРазличия результатов обусловлены тем, что в 1-ом случае мы складываем числа, во 2-ом - строки.</string>

    <string name="theory.5.text">"    "Основными условными операторами в C# являются if и switch. Рассмотрим каждый отдельно.


        \n\n"  "if (условие){
        \n"  ""    "(…)
        \n"  "}
        \n"  "else{
        \n"  ""    "(…)
        \n"  "}
        \n"    "Вместо многоточия можно поставить любую часть программы. На месте условия может находиться все, что является истинным или ложным. Так, например, можно проверить числа на равенство или строки на идентичность:
        \n"  "if (4 == 2){…}
        \n"  "if ("Hello" == "world"){…}
        \n"    "В обоих случаях получим ложь, следовательно, часть программы в фигурных скобках не будет выполнена.

        \n\n"    "Также в качестве условия может выступать какая-то логическая переменная:
        \n"  "bool flag = true;
        \n"  "if (flag) { (1) }
        \n"  "else { (2) }
        \n"    "В данном примере выполнится часть кода (1), часть кода (2) не будет выполнена.


        \n\n\n"    "Оператор switch обеспечивает многонаправленное ветвление программы.
        \nРассмотрим простой пример, сравнивающий числа:
        \n"  "int x = 4 + 3;
        \n"  "switch(x){
        \n"  ""    "case (4):
        \n"  ""    ""    "Console.Write("x равен 4");
        \n"  ""    ""    "break;
        \n"  ""    "case (7):
        \n"  ""    ""    "Console.Write("x равен 7");
        \n"  ""    ""    "break;
        \n"  ""    "default:
        \n"  ""    ""    "Console.Write("x не равен 7 и x не равен 4");
        \n"  ""    ""    "break;
        \n"  "}
        \nВ результате работы этой части программы будет напечатано:
        \n"  "x равен 7
        \n\nБлок default выполняется, когда ни одно из остальных условий не было выполнено.</string>

    <string name="theory.6.text"><![CDATA["    "Цикл for в C# представляет механизм, в котором определенное условие проверяется перед выполнением каждой итерации. Синтаксис этого оператора показан ниже:
        \n"  "for (инициализатор; условие; итератор) {
        \n"  ""    "(…)
        \n"  "}
        \n"    "Инициализатор - это выражение, вычисляемое перед первым выполнением тела цикла.
        \n"    "Условие - это выражение, проверяемое перед каждой новой итерацией цикла.
        \n"    "Итератор - выражение, вычисляемое после каждой итерации.

        \n\nПример цикла, выводящего все цифры от 1 до 9 через пробел:
        \n"  "for (int i = 1; i < 10; i++){
        \n"  ""    "Console.Write(i + \" \");
        \n"  "}
        \n"    "При первом входе в цикл переменная i равна 1, с каждой итерацией ее значение увелчивается на 1, так происходит, пока i меньше 10. Как только она становится больше или равной 10, цикл прекращается.]]></string>

    <string name="theory.7.text"><![CDATA["    "В C# имеются циклы с проверкой как до выполнения действия, так и после. Рассмотрим каждый отдельно.

        \n\n"  "while(условие){
        \n"  ""    "(…)
        \n"  "}
        \n"    "Из-за того, что в данной конструкции нет итератора, его нужно будет заменить чем-то в самом теле цикла.

        \n\n"    "Например, нужно выводить в консоль числа, начиная с 1, пока их сумма будет меньше или равна 70:
        \n"  "int a = 1, sum = 0;
        \n"  "while (sum + a <= 70) {
        \n"  ""    "Console.WriteLine(a + " ");
        \n"  ""    "sum += a;
        \n"  ""    "a++;
        \n"  "}
        \n"  "В результате работы программы будут выведены числа от 1 до 11.

        \n\n"    "Также цикл while позволяет писать бесконечные циклы.
        \n"  "while (true) {
        \n"  ""    "(…)
        \n"  "}
        \n"    "Подобные конструкции могут пригодиться в олимпиадной практике, но при написании различных проектов лучше избегать бесконечных циклов.


        \n\n"  "do {
        \n"  ""    "(…)
        \n"  "} while(условие);
        \n"    "Данный цикл отличается тем, что условие проверяется только после выполнения кода, находящегося в теле цикла. Поэтому, код в теле цикла while может быть не исполнен ни разу, а в теле цикла do-while один раз точно исполнится.

        \n\n"    "Тип цикла стоит выбирать в зависимости от того, что требуется для каждой конкретной задачи, поэтому важно уметь пользоваться и тем, и другим.]]></string>

    <string name="theory.8.text"><![CDATA["    "Массив представляет собой совокупность переменных одного типа с общим для обращения к ним именем. В C# массивы могут быть как одномерными, так и многомерными. Массивы служат самым разным целям, поскольку они предоставляют удобные средства для объединения связанных вместе переменных.

        \n"    "Существует несколько способов задания массива:

        \n\n"  "int[] myArr = new int[5];
        \n"  "myArr[0] = 3;
        \n"  "myArr[1] = 312;
        \n"  "myArr[2] = 2;
        \n"  "myArr[3] = 231;
        \n"  "myArr[4] = 1;
        \n"    "В данном примере мы сначала инициализируем массив (1 строка), затем задаем каждый элемент массива вручную. Так как в данном случае мы имеем массив с неизменяемой длиной, то ее необходимо указать в скобках при инициализации.
        \n!!! Индексация элементов массива начинается с 0 !!!

        \n\n"  "int[] myArray = new int[] {1, 2, 3, 4, 5};
        \n"  "string[] info = { \"Иванов\", \"Иван\", \"Иванович\" };
        \n"  "char[] symbols = new char[] { \'А\', \'Т\', \'Z\', \'U\' };
        \nВ случае применения синтаксиса с фигурными скобками размер массива указывать не требуется, поскольку этот размер автоматически вычисляется на основе количества элементов внутри фигурных скобок.

        \n\nЧтобы узнать длину массива, можем воспользоваться методом:
        \n"  "int[] myArray = new int[] {1, 9, 3, 4, 5, 8};
        \n"  "Console.WriteLine(myArray.Length);
        \n"  "В результате в консоль будет выведена цифра 6, так как в массиве myArray 6 элементов.

        \n\n"    "Для вывода элеметов массива в столбик проще всего использовать цикл for:
        \n"  "int[] myArray = new int[] {1, 9, 3, 4, 5, 8};
        \n"  "for (int i = 0; i < myArray.Length; i++){
        \n"  ""    "Console.WriteLine(myArray[i]);
        \n"  "}
        \n\n"    "Либо использовать цикл foreach:
        \n"  "int[] myArray = new int[] {1, 9, 3, 4, 5, 8};
        \n"  "foreach (int x in myArray){
        \n"  ""    "Console.WriteLine(x);
        \n"  "}
        \nДословно: для каждого целочисленного элемента массива х.


        \n\n\n"    "Также, в C# представлены динамические массивы - массивы с изменяемым количеством элементов.
        \n"  "List<string> a = new List<string>();
        \nДля добавления элемента в конец массива существует метод:
        \n"  "a.Add(\"hello\");
        \nЧтобы узнать длину динамического массива, используют метод:
        \n"  "a.Count]]></string>

    <string name="theory.9.text">"    "Сортировка массива - процесс, в результате которого элементы массива упорядочиваются по возрастанию или убыванию. Сортировать можно как массивы с числами, так и со строками.
        \n"    "В C# есть встроенная сортировка, что, бесспорно, удобно, когда нет времени писать свою. Но в некоторых задачах требуется не просто отсортировать массив, а еще, скажем, посчитать количество совершенных перестановок. В этом случае не обойтись без знаний об алгоритмах сортировок и их особенностях.

        \n\n"    "Самой простой, несомненно, является Bubble Sort или сортировка пузырьком. Суть данной сортировки предельно проста: проходимся по массиву от начала до конца, если два соседних элемента не упорядоченны, то меняем их местами.

        \n\n"    "Одной из самых эффективных сортировок является сортировка Хоара или QuickSort. Умение писать данную сортировку необходимо каждому начинающему программисту, кроме, наверное, frontend-разработчика.(Хотя, в любом случае лишним не будет)
        \nСуть данной сортировки такова:
        \n"  "1) Выбираем из массива опорный элемент. Опорным может быть любой элемент.
        \n"  "2) Сравниваем значения всех элементов со значением опорного. Переставляем эти элементы так, чтобы сначала стояли элементы, меньше опорного, затем - равные ему, после - больше.
        \n"  "3) Отдельно для меньших и для больших выполняем тот же алгоритм, пока длины подмассива меньших и подмассива больших больше 1.
        \n"    "Мы вернемся к рассмотрению этой сортировки в теме функций, в частноси, рекурсии, но сейчас необходимо запомнить саму структуру алгоритма.

        \n\n"    "В данном тексте умышленно отсутствуют написанные алгоритмы сортировкок, так как очень часто понять алгоритм не так трудно, как написать рабочую реализацию, поэтому эта задача оставляется для самостоятельной деятельности.

        \n\nБольше информации о сортировках по ссылке:
        \nhttps://habr.com/post/204600/</string>


    <string name="theory.10.text"><![CDATA["    "В данной части теоретического материала мы рассмотрим два важных понятия: матрицы и массивы массивов.


        \n\n\n"    "В обычном понимании матрицу можно представить как прямоугольную таблицу n*m, где n - количество строк, а m - количество столбцов. Далее приведем небольшой пример использования матрицы:
        \n"  "Есть данные о температуре ночью, утром, днем и вечером, собранные за 3 дня. Необходимо найти день, в который была достигнута минимальная температура.

        \n\n"  "int n = 3, m = 4, day = -1, min_t = 100;
        \n"  "int[,] a = { { 1, 3, 5, 2}, {13, 6, 7, -2}, { 4, 2, 0, 11} };
        \n"  "for (int i = 0; i < n; i++) {
        \n"  ""    "for (int j = 0; j < m; j++) {
        \n"  ""    ""    "if (min_t > a[i, j]) {
        \n"  ""    ""    ""    "min_t = a[i, j];
        \n"  ""    ""    ""    "day = i + 1;
        \n"  ""    ""    "}
        \n"  ""    "}
        \n"  "}
        \n"  "Console.WriteLine($\"Минимальная температура была достигнута на {day} день\");
        \n"  "В 1-ой строке мы инициализируем все необходимые переменные: количество строк и столбцов, номер дня и минимальная температура. Во 2-ой - задаем матрицу. Далее с помощью цикла проходим по всем \"ячейкам\", находим минимальное значение и запоминаем номер дня. В конце выводим ответ на задачу.

        \n\n"    "Также, иногда нужно вывести матрицу в консоль в виде таблицы. Для этого воспользуемся форматированием строк:

        \n\n"  "for (int i = 0; i < n; i++){
        \n"  ""    "for (int j = 0; j < m; j++){
        \n"  ""    ""    "Console.Write(\"{0,3:d}\", a[i, j]);
        \n"  ""    "}
        \n"  ""    "Console.WriteLine();
        \n"  "}
        \nВ консоли после выполнения цикла получаем:
        \n  1  3  5  2
        \n 13  6  7 -2
        \n  4  2  0 11
        \n"  "Рассмотрим подробнее конструкцию \"{0,3:d}\": 3 - количество \"ячеек\" для вывода, d - указатель на то, что выводится целое число.


        \n\n\n"    "Самый простой пример массива массивов - массив строк. Строка - неизменяемый массив символов(char).
        \n"  "Отличием массива массивов от матрицы является то, что длина строк может быть разной.

        \n\n"  "int n = 3;
        \n"  "int[][] a = new int[n][];
        \n"  "for (int i = 0; i < n; i++){
        \n"  ""    "a[i] = new int[i+1];
        \n"  "}
        \nВ данном примере мы инициализировали массив массивов из 3 строк, длина каждой строки больше длины предыдущей на 1.
        \nДла вывода можно использовать следующий цикл:
        \n"  "for (int i = 0; i < a.Length; i++) {
        \n"  ""    "for (int j = 0; j < a[i].Length; j++) {
        \n"  ""    ""    "Console.Write(\"{0,3:d}\", a[i][j]);
        \n"  ""    "}
        \n"  ""    "Console.WriteLine();
        \n"  "}]]></string>

    <string name="theory.11.text"><![CDATA["    "В контексте объектно-ориентированного программирования, метод – это подпрограмма, которую написать нужно один раз, а использовать ее можно многократно (для выполнения однотипных действий). Так, например, с помощью методов можно разбить большую программу на меньшие, отвечающие за какие-то конктретные действия, тем самым повысив читаемость кода.
        \nНиже приведена структура определения метода:
        \n"  "[модификаторы доступа] типВозвращаемогоЗначения ИмяМетода([параметры])
        \n"  "{
        \n"    ""  "Тело метода;
        \n"  "}

        \n\nМодификаторы доступа:
        \n- public (метод доступен в любой части кода)
        \n- protected (метод доступен в данном классе и в производных)
        \n- private (метод доступен только в данном классе)

        \n\nТип возвращаемого значения:
        \n- Типы данных (int, string, char, List<char> и т.д.)
        \n- void (никакое значение не возвращается)
        \n"  "Если метод должен возвращать какой-либо тип данных, в конце метода необходимо ключевое слово return и после него должно стоять число строка и т.д.

        \n\n"  "Параметры метода - переменные и объекты, которые передаются в метод.
        \n"  "Тело метода - программный код, который выполняется при вызове метода.


        \n\nНапример, необходимо посчитать средние значения нескольких наборов чисел:
        \n"  "public double Average(int[] a){
        \n"  ""    "double answer = 0.0;
        \n"  ""    "for (int i = 0; i < a.Length; i++){
        \n"  ""    ""    "answer += a[i];
        \n"  ""    "}
        \n"  ""    "answer /= a.Length;
        \n"  ""    "return answer;
        \n"  "}
        \nИспользуется возвращаемый тип double, т.к. среднее значение чаще всего является дробным числом.

        \n\nТакже, методы могут помочь, если необходимо несколько раз выводить массивы, одинакового типа:
        \n"  "public void Print(List<string> a) {
        \n"  ""    "foreach (string x in a) {
        \n"  ""    ""    "Console.Write(x + \" \");
        \n"  ""    "}
        \n"  "}]]></string>

    <string name="theory.12.text"><![CDATA["    "В C# при объявлении двух или более методов с одним названием и одинаковыми параметрами появляется ошибка, но допускается совместное использование одного и того же имени двумя или более методами одного и того же класса, при условии, что их параметры объявляются по-разному. В этом случае говорят, что методы перегружаются, а сам процесс называется перегрузкой методов.
        \n"    "Проще говоря, параметры, передаваемые в метод, должны либо быть разных типов, либо их количество или порядок должны отличаться.

        \n\n"    "К примеру, в классе Program объявлены 4 метода с одним названием Print.
        \n"  "static void Print(string name)
        \n"  "{
        \n"  ""    "Console.WriteLine($\"Данный метод распечатывает одно слово: {name}\");
        \n"  "}
        \n"  "static void Print(string name1, string name2)
        \n"  "{
        \n"  ""    "Console.WriteLine($\"Данный метод распечатывает два слова: {name1} и {name2}\");
        \n"  "}
        \n"  "static void Print(List<int> a)
        \n"  "{
        \n"  ""    "for (int i = 0; i < a.Count; i++) {
        \n"  ""    ""    "Console.Write(a[i] + \" \");
        \n"  ""    "}
        \n"  "}
        \n"  "static void Print(int[] a)
        \n"  "{
        \n"  ""    "for (int i = 0; i < a.Length; i++) {
        \n"  ""    ""    "Console.Write(a[i] + \" \");
        \n"  ""    "}
        \n"  "}
        \n"    "Теперь, если в основном методе вызвать метод Print(\"Привет\"), то в консоль будет выведена строка \"Данный метод распечатывает одно слово: Привет\".
        \n"    "Если же вызвать метод Print(\"Привет\", \"Мир\"), то в консоли будет строка \"Данный метод распечатывает два слова: Привет и Мир\".
        \n"    "При передачи List<int> или int[], последовательность чисел будет выведена в строку.]]></string>

    <string name="theory.13.text">"    "Фраза \"Чтобы понять рекурсию, нужно понять рекурсию\" может дать примерное представление об этом понятии, а может и запутать окончательно.
        \n"    "Часто вместо решения какой-то большой задачи бывает проще разбить ее на небольшие подзадачи и решать их. Это и позволяет сделать рекурсия.

        \n\n"    "Рассмотрим простой пример: Нужно найти n!(факториал). Для этого можно просто запустить цикл, а можно написать рекурсивную функцию:

        \n\n"  "static int F(int n) {
        \n"  ""    "if (n == 1) return 1;
        \n"  ""    "return F(n - 1) * n;
        \n"  "}

        \n\nНапример, 4! можно представить так:
        \n"  "f(4) -> 4 * f(3)
        \n"  "f(3) -> 3 * f(2)
        \n"  "f(2) -> 2 * f(1)
        \n"  "f(1) -> 1


        \n\n\n"    "Чтобы найти, например, 5-е число последовательности Фибоначчи, нужно сначала посчитать два предыдущих числа. Известно, что значение 1-ого члена равно 0, а 2-ого - 1. На основе этих данных можно решить задачу расчета n-ого члена последовательности:

        \n\n"  "static int Fib(int n) {
        \n"  ""    "if (n == 0) return 0;
        \n"  ""    "else if (n == 1) return 1;
        \n"  ""    "return Fib(n - 1) + Fib(n - 2);
        \n"  "}</string>





</resources>